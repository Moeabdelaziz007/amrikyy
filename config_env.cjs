#!/usr/bin/env node

require('dotenv').config();
const fs = require('fs').promises;
const path = require('path');

/**
 * ‚öôÔ∏è Configuration & Environment Manager
 * ÿ•ÿØÿßÿ±ÿ© ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÜÿ∏ÿßŸÖ ŸàŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ®Ÿäÿ¶ÿ©
 * ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ŸÉŸàŸäŸÜ Ÿàÿ•ÿπÿØÿßÿØ ÿßŸÑŸÜÿ∏ÿßŸÖ
 */
class ConfigManager {
    constructor() {
        this.config = {
            system: {
                name: 'AuraOS Autopilot System',
                version: '1.0.0',
                environment: process.env.NODE_ENV || 'development',
                port: process.env.PORT || 3000,
                debug: process.env.DEBUG === 'true'
            },
            firebase: {
                projectId: process.env.FIREBASE_PROJECT_ID,
                privateKey: process.env.FIREBASE_PRIVATE_KEY,
                clientEmail: process.env.FIREBASE_CLIENT_EMAIL
            },
            telegram: {
                botToken: process.env.TELEGRAM_BOT_TOKEN,
                adminChatId: process.env.TELEGRAM_ADMIN_CHAT_ID
            },
            ai: {
                googleApiKey: process.env.GOOGLE_AI_API_KEY,
                model: 'gemini-pro',
                temperature: 0.3,
                maxTokens: 2048
            },
            autopilot: {
                maxConcurrentTasks: 10,
                taskTimeout: 300000, // 5 minutes
                agentTimeout: 60000, // 1 minute
                feedbackInterval: 300000, // 5 minutes
                cleanupInterval: 3600000 // 1 hour
            },
            logging: {
                level: process.env.LOG_LEVEL || 'info',
                maxFileSize: '10MB',
                maxFiles: 5,
                retentionDays: 7
            },
            analytics: {
                enabled: true,
                dashboardUpdateInterval: 60000, // 1 minute
                reportInterval: 900000, // 15 minutes
                analysisInterval: 3600000 // 1 hour
            }
        };
        
        this.validationRules = {
            firebase: {
                projectId: { required: true, type: 'string', minLength: 5 },
                privateKey: { required: true, type: 'string', pattern: /-----BEGIN PRIVATE KEY-----/ },
                clientEmail: { required: true, type: 'string', pattern: /@.*\.iam\.gserviceaccount\.com$/ }
            },
            telegram: {
                botToken: { required: true, type: 'string', pattern: /^\d+:[A-Za-z0-9_-]+$/ },
                adminChatId: { required: true, type: 'string', pattern: /^-?\d+$/ }
            },
            ai: {
                googleApiKey: { required: true, type: 'string', minLength: 20 }
            }
        };
        
        this.errors = [];
        this.warnings = [];
        
        console.log('‚öôÔ∏è Configuration Manager initialized');
    }

    /**
     * ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿ™ŸÉŸàŸäŸÜ
     */
    validateConfig() {
        this.errors = [];
        this.warnings = [];
        
        console.log('üîç Validating configuration...');
        
        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Firebase
        this.validateFirebaseConfig();
        
        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Telegram
        this.validateTelegramConfig();
        
        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Google AI
        this.validateAIConfig();
        
        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿπÿßŸÖÿ©
        this.validateSystemConfig();
        
        // ÿπÿ±ÿ∂ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨
        this.displayValidationResults();
        
        return this.errors.length === 0;
    }

    /**
     * ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ÿπÿØÿßÿØÿßÿ™ Firebase
     */
    validateFirebaseConfig() {
        const firebase = this.config.firebase;
        const rules = this.validationRules.firebase;
        
        Object.entries(rules).forEach(([key, rule]) => {
            const value = firebase[key];
            
            if (rule.required && (!value || value.includes('your_') || value.includes('YOUR_'))) {
                this.errors.push(`Firebase ${key} is required and must be configured`);
            } else if (value) {
                if (rule.type && typeof value !== rule.type) {
                    this.errors.push(`Firebase ${key} must be a ${rule.type}`);
                }
                if (rule.minLength && value.length < rule.minLength) {
                    this.errors.push(`Firebase ${key} must be at least ${rule.minLength} characters`);
                }
                if (rule.pattern && !rule.pattern.test(value)) {
                    this.errors.push(`Firebase ${key} format is invalid`);
                }
            }
        });
    }

    /**
     * ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ÿπÿØÿßÿØÿßÿ™ Telegram
     */
    validateTelegramConfig() {
        const telegram = this.config.telegram;
        const rules = this.validationRules.telegram;
        
        Object.entries(rules).forEach(([key, rule]) => {
            const value = telegram[key];
            
            if (rule.required && (!value || value.includes('your_') || value.includes('YOUR_'))) {
                this.errors.push(`Telegram ${key} is required and must be configured`);
            } else if (value) {
                if (rule.type && typeof value !== rule.type) {
                    this.errors.push(`Telegram ${key} must be a ${rule.type}`);
                }
                if (rule.pattern && !rule.pattern.test(value)) {
                    this.errors.push(`Telegram ${key} format is invalid`);
                }
            }
        });
    }

    /**
     * ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ÿπÿØÿßÿØÿßÿ™ Google AI
     */
    validateAIConfig() {
        const ai = this.config.ai;
        const rules = this.validationRules.ai;
        
        Object.entries(rules).forEach(([key, rule]) => {
            const value = ai[key];
            
            if (rule.required && (!value || value.includes('your_') || value.includes('YOUR_'))) {
                this.errors.push(`Google AI ${key} is required and must be configured`);
            } else if (value) {
                if (rule.type && typeof value !== rule.type) {
                    this.errors.push(`Google AI ${key} must be a ${rule.type}`);
                }
                if (rule.minLength && value.length < rule.minLength) {
                    this.errors.push(`Google AI ${key} must be at least ${rule.minLength} characters`);
                }
            }
        });
    }

    /**
     * ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿπÿßŸÖÿ©
     */
    validateSystemConfig() {
        const system = this.config.system;
        
        if (system.port < 1000 || system.port > 65535) {
            this.warnings.push('Port should be between 1000 and 65535');
        }
        
        if (system.environment === 'production' && system.debug) {
            this.warnings.push('Debug mode should be disabled in production');
        }
    }

    /**
     * ÿπÿ±ÿ∂ ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ™ÿ≠ŸÇŸÇ
     */
    displayValidationResults() {
        console.log('='.repeat(60));
        
        if (this.errors.length === 0) {
            console.log('‚úÖ Configuration validation passed');
        } else {
            console.log('‚ùå Configuration validation failed:');
            this.errors.forEach(error => {
                console.log(`   - ${error}`);
            });
        }
        
        if (this.warnings.length > 0) {
            console.log('‚ö†Ô∏è Warnings:');
            this.warnings.forEach(warning => {
                console.log(`   - ${warning}`);
            });
        }
        
        console.log('='.repeat(60));
    }

    /**
     * ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÑŸÅ ÿ™ŸÉŸàŸäŸÜ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
     */
    async createDefaultConfig() {
        try {
            const defaultConfig = {
                system: {
                    name: 'AuraOS Autopilot System',
                    version: '1.0.0',
                    environment: 'development',
                    port: 3000,
                    debug: true
                },
                firebase: {
                    projectId: 'your-firebase-project-id',
                    privateKey: '-----BEGIN PRIVATE KEY-----\nYOUR_PRIVATE_KEY_HERE\n-----END PRIVATE KEY-----\n',
                    clientEmail: 'firebase-adminsdk-xxxxx@your-project.iam.gserviceaccount.com'
                },
                telegram: {
                    botToken: 'your_bot_token_here',
                    adminChatId: 'your_chat_id_here'
                },
                ai: {
                    googleApiKey: 'your_gemini_api_key_here',
                    model: 'gemini-pro',
                    temperature: 0.3,
                    maxTokens: 2048
                },
                autopilot: {
                    maxConcurrentTasks: 10,
                    taskTimeout: 300000,
                    agentTimeout: 60000,
                    feedbackInterval: 300000,
                    cleanupInterval: 3600000
                },
                logging: {
                    level: 'info',
                    maxFileSize: '10MB',
                    maxFiles: 5,
                    retentionDays: 7
                },
                analytics: {
                    enabled: true,
                    dashboardUpdateInterval: 60000,
                    reportInterval: 900000,
                    analysisInterval: 3600000
                }
            };

            const configFile = path.join(process.cwd(), 'config.json');
            await fs.writeFile(configFile, JSON.stringify(defaultConfig, null, 2));
            
            console.log('üìù Default configuration file created: config.json');
            return configFile;

        } catch (error) {
            console.error('‚ùå Failed to create default config:', error);
            throw error;
        }
    }

    /**
     * ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ™ŸÉŸàŸäŸÜ ŸÖŸÜ ŸÖŸÑŸÅ
     */
    async loadConfigFromFile(configPath) {
        try {
            const configData = await fs.readFile(configPath, 'utf8');
            const fileConfig = JSON.parse(configData);
            
            // ÿØŸÖÿ¨ ÿßŸÑÿ™ŸÉŸàŸäŸÜ ŸÖŸÜ ÿßŸÑŸÖŸÑŸÅ ŸÖÿπ ÿßŸÑÿ™ŸÉŸàŸäŸÜ ÿßŸÑÿ≠ÿßŸÑŸä
            this.config = this.mergeConfigs(this.config, fileConfig);
            
            console.log(`üìÅ Configuration loaded from: ${configPath}`);
            return true;

        } catch (error) {
            console.error('‚ùå Failed to load config from file:', error);
            return false;
        }
    }

    /**
     * ÿØŸÖÿ¨ ÿßŸÑÿ™ŸÉŸàŸäŸÜÿßÿ™
     */
    mergeConfigs(baseConfig, fileConfig) {
        const merged = { ...baseConfig };
        
        Object.keys(fileConfig).forEach(key => {
            if (typeof fileConfig[key] === 'object' && !Array.isArray(fileConfig[key])) {
                merged[key] = { ...merged[key], ...fileConfig[key] };
            } else {
                merged[key] = fileConfig[key];
            }
        });
        
        return merged;
    }

    /**
     * ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÉŸàŸäŸÜ ÿ•ŸÑŸâ ŸÖŸÑŸÅ
     */
    async saveConfigToFile(configPath) {
        try {
            await fs.writeFile(configPath, JSON.stringify(this.config, null, 2));
            console.log(`üíæ Configuration saved to: ${configPath}`);
            return true;

        } catch (error) {
            console.error('‚ùå Failed to save config to file:', error);
            return false;
        }
    }

    /**
     * ÿ™ÿ≠ÿØŸäÿ´ ŸÇŸäŸÖÿ© ŸÅŸä ÿßŸÑÿ™ŸÉŸàŸäŸÜ
     */
    updateConfig(path, value) {
        const keys = path.split('.');
        let current = this.config;
        
        for (let i = 0; i < keys.length - 1; i++) {
            if (!current[keys[i]]) {
                current[keys[i]] = {};
            }
            current = current[keys[i]];
        }
        
        current[keys[keys.length - 1]] = value;
        console.log(`‚öôÔ∏è Updated config: ${path} = ${value}`);
    }

    /**
     * ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÇŸäŸÖÿ© ŸÖŸÜ ÿßŸÑÿ™ŸÉŸàŸäŸÜ
     */
    getConfig(path) {
        const keys = path.split('.');
        let current = this.config;
        
        for (const key of keys) {
            if (current[key] === undefined) {
                return undefined;
            }
            current = current[key];
        }
        
        return current;
    }

    /**
     * ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ™ŸÉŸàŸäŸÜ ÿßŸÑŸÉÿßŸÖŸÑ
     */
    getFullConfig() {
        return this.config;
    }

    /**
     * ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ™ŸÉŸàŸäŸÜ ÿßŸÑÿ¢ŸÖŸÜ (ÿ®ÿØŸàŸÜ ŸÖŸÅÿßÿ™Ÿäÿ≠ ÿ≠ÿ≥ÿßÿ≥ÿ©)
     */
    getSafeConfig() {
        const safeConfig = { ...this.config };
        
        // ÿ•ÿÆŸÅÿßÿ° ÿßŸÑŸÖŸÅÿßÿ™Ÿäÿ≠ ÿßŸÑÿ≠ÿ≥ÿßÿ≥ÿ©
        if (safeConfig.firebase.privateKey) {
            safeConfig.firebase.privateKey = '***HIDDEN***';
        }
        if (safeConfig.telegram.botToken) {
            safeConfig.telegram.botToken = '***HIDDEN***';
        }
        if (safeConfig.ai.googleApiKey) {
            safeConfig.ai.googleApiKey = '***HIDDEN***';
        }
        
        return safeConfig;
    }

    /**
     * ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ŸÉŸàŸäŸÜ
     */
    generateConfigReport() {
        const report = {
            timestamp: new Date().toISOString(),
            validation: {
                passed: this.errors.length === 0,
                errors: this.errors,
                warnings: this.warnings
            },
            config: this.getSafeConfig(),
            environment: {
                nodeVersion: process.version,
                platform: process.platform,
                arch: process.arch,
                cwd: process.cwd()
            }
        };
        
        return report;
    }

    /**
     * ÿ∑ÿ®ÿßÿπÿ© ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ŸÉŸàŸäŸÜ
     */
    printConfigReport() {
        const report = this.generateConfigReport();
        
        console.log('üìä Configuration Report');
        console.log('='.repeat(60));
        console.log(`üïê Generated: ${report.timestamp}`);
        console.log(`‚úÖ Validation: ${report.validation.passed ? 'PASSED' : 'FAILED'}`);
        console.log(`üåç Environment: ${report.environment.platform} ${report.environment.arch}`);
        console.log(`üìÅ Working Directory: ${report.environment.cwd}`);
        console.log('='.repeat(60));
        
        if (report.validation.errors.length > 0) {
            console.log('‚ùå Errors:');
            report.validation.errors.forEach(error => {
                console.log(`   - ${error}`);
            });
        }
        
        if (report.validation.warnings.length > 0) {
            console.log('‚ö†Ô∏è Warnings:');
            report.validation.warnings.forEach(warning => {
                console.log(`   - ${warning}`);
            });
        }
        
        console.log('='.repeat(60));
    }

    /**
     * ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑÿ™ŸÉŸàŸäŸÜ ÿ•ŸÑŸâ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
     */
    resetToDefault() {
        this.config = {
            system: {
                name: 'AuraOS Autopilot System',
                version: '1.0.0',
                environment: 'development',
                port: 3000,
                debug: true
            },
            firebase: {
                projectId: process.env.FIREBASE_PROJECT_ID,
                privateKey: process.env.FIREBASE_PRIVATE_KEY,
                clientEmail: process.env.FIREBASE_CLIENT_EMAIL
            },
            telegram: {
                botToken: process.env.TELEGRAM_BOT_TOKEN,
                adminChatId: process.env.TELEGRAM_ADMIN_CHAT_ID
            },
            ai: {
                googleApiKey: process.env.GOOGLE_AI_API_KEY,
                model: 'gemini-pro',
                temperature: 0.3,
                maxTokens: 2048
            },
            autopilot: {
                maxConcurrentTasks: 10,
                taskTimeout: 300000,
                agentTimeout: 60000,
                feedbackInterval: 300000,
                cleanupInterval: 3600000
            },
            logging: {
                level: 'info',
                maxFileSize: '10MB',
                maxFiles: 5,
                retentionDays: 7
            },
            analytics: {
                enabled: true,
                dashboardUpdateInterval: 60000,
                reportInterval: 900000,
                analysisInterval: 3600000
            }
        };
        
        console.log('üîÑ Configuration reset to default');
    }
}

// ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ŸÉŸàŸäŸÜ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖŸÑŸÅ Ÿäÿ™ŸÖ ÿ™ŸÜŸÅŸäÿ∞Ÿá ŸÖÿ®ÿßÿ¥ÿ±ÿ©
async function main() {
    try {
        const configManager = new ConfigManager();
        
        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ŸÉŸàŸäŸÜ
        const isValid = configManager.validateConfig();
        
        // ÿ∑ÿ®ÿßÿπÿ© ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ŸÉŸàŸäŸÜ
        configManager.printConfigReport();
        
        if (!isValid) {
            console.log('\nüìù To fix configuration issues:');
            console.log('1. Update your .env file with correct values');
            console.log('2. Run: node config_env.cjs --create-default');
            console.log('3. See AURAOS_SETUP_GUIDE.md for detailed instructions');
            process.exit(1);
        }
        
        console.log('\n‚úÖ Configuration is valid and ready to use!');
        
    } catch (error) {
        console.error('‚ùå Configuration check failed:', error);
        process.exit(1);
    }
}

// ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ£ŸàÿßŸÖÿ±
if (require.main === module) {
    const args = process.argv.slice(2);
    
    if (args.includes('--create-default')) {
        const configManager = new ConfigManager();
        configManager.createDefaultConfig()
            .then(() => {
                console.log('‚úÖ Default configuration created');
                process.exit(0);
            })
            .catch(error => {
                console.error('‚ùå Failed to create default config:', error);
                process.exit(1);
            });
    } else {
        main();
    }
}

module.exports = ConfigManager;
